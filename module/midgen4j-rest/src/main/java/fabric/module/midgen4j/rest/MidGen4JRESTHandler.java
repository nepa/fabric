/** 25.09.2012 22:14 */
package fabric.module.midgen4j.rest;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Properties;
import java.util.Collections;

import de.uniluebeck.sourcegen.Workspace;
import fabric.module.api.FDefaultWSDLHandler;

import de.uniluebeck.sourcegen.java.JClass;
import de.uniluebeck.sourcegen.java.JClassAnnotationImpl;
import de.uniluebeck.sourcegen.java.JClassCommentImpl;
import de.uniluebeck.sourcegen.java.JConstructor;
import de.uniluebeck.sourcegen.java.JField;
import de.uniluebeck.sourcegen.java.JFieldCommentImpl;
import de.uniluebeck.sourcegen.java.JMethod;
import de.uniluebeck.sourcegen.java.JMethodAnnotationImpl;
import de.uniluebeck.sourcegen.java.JMethodCommentImpl;
import de.uniluebeck.sourcegen.java.JMethodSignature;
import de.uniluebeck.sourcegen.java.JModifier;
import de.uniluebeck.sourcegen.java.JParameter;
import de.uniluebeck.sourcegen.java.JSourceFile;

import fabric.wsdlschemaparser.wsdl.FOperation;
import fabric.wsdlschemaparser.wsdl.FPortType;

/**
 * Fabric handler class to extend the Java Middleware Generator. This
 * handler creates a RESTful interface for the central service provider
 * class that is generated by the base MidGen4JHandler. The REST handler
 * defines a couple of callback methods to process WSDL files and can
 * create a REST resource class for the service.
 *
 * @author seidel
 */
public class MidGen4JRESTHandler extends FDefaultWSDLHandler
{
  /** Logger object */
  private static final Logger LOGGER = LoggerFactory.getLogger(MidGen4JRESTHandler.class);

  /** Workspace object for code write-out */
  private Workspace workspace;

  /** Properties object for module configuration */
  private Properties properties;

  /** List of required Java imports */
  private ArrayList<String> requiredImports;

  /** Java package name for REST interface class */
  private String packageName;

  /** Name of the REST service interface class */
  private String restInterfaceClassName;

  /** Java packane name of service provider class */
  private String serviceProviderPackageName;

  /** Class with REST service interface */
  private JClass restInterfaceClass;

  /**
   * Constructor initializes the MidGen4J REST handler, which
   * can create a RESTful service interface.
   *
   * @param workspace Workspace object for source code write-out
   * @param properties Properties object with module options
   */
  public MidGen4JRESTHandler(Workspace workspace, Properties properties) throws Exception
  {
    this.workspace = workspace;
    this.properties = properties;
    this.requiredImports = new ArrayList<String>();

    // Extract global properties
    this.packageName = this.properties.getProperty(MidGen4JRESTModule.PACKAGE_NAME_KEY);
    this.restInterfaceClassName = this.properties.getProperty(MidGen4JRESTModule.INTERFACE_CLASS_NAME_KEY);
    this.serviceProviderPackageName = this.properties.getProperty(MidGen4JRESTModule.SERVICE_PROVIDER_PACKAGE_NAME_KEY);
  }

  /**
   * Create class with RESTful service interface before processing
   * any other element of the WSDL document.
   *
   * @throws Exception Error during code generation
   */
  @Override
  public void executeBeforeProcessing() throws Exception
  {
    this.restInterfaceClass = this.createRESTInterfaceClass();

    // Add class to source file
    JSourceFile jsf = this.workspace.getJava().getJSourceFile(this.packageName, this.restInterfaceClassName);
    jsf.add(this.restInterfaceClass);
  }

  /**
   * Create main method in REST interface class and add required
   * Java imports to source file, after processing all elements
   * of the WSDL document.
   *
   * @throws Exception Error during code generation
   */
  @Override
  public void executeAfterProcessing() throws Exception
  {
    // Add main method to REST interface class
    this.addMainMethod(this.restInterfaceClass);

    // Add required imports to source file
    JSourceFile jsf = this.workspace.getJava().getJSourceFile(this.packageName, this.restInterfaceClassName);

    // Sort list alphabetically
    Collections.sort(this.requiredImports);
    for (String requiredImport: this.requiredImports)
    {
      jsf.addImport(requiredImport);
    }
  }

  /**
   * Process port types (WSDL 2.0: interfaces) that are defined in WSDL document.
   *
   * @param portTypes Port types of WSDL document
   *
   * @throws Exception Error during processing
   */
  @Override
  public void processPortTypes(final HashSet<FPortType> portTypes) throws Exception
  {
    if (null != this.restInterfaceClass)
    {
      // Process all service operations
      for (FPortType portType: portTypes)
      {
        for (FOperation operation: portType.getOperations())
        {
          // Create handler for each REST request
          this.restInterfaceClass.add(this.createRequestHandlerMethod(operation));
        }
      }
    }
  }

  /**
   * Create class for RESTful service interface.
   *
   * @return JClass object with RESTful service interface class
   *
   * @throws Exception Error during code generation
   */
  private JClass createRESTInterfaceClass() throws Exception
  {
    JClass restInterface = JClass.factory.create(JModifier.PUBLIC, this.restInterfaceClassName);

    LOGGER.debug(String.format("Created RESTful service interface class '%s'.", this.restInterfaceClassName));

    // Add a comment
    restInterface.setComment(new JClassCommentImpl(String.format(
            "The '%s' RESTful service interface class.", this.restInterfaceClassName)));

    // Add annotation for JAX-RS/Jersey
    restInterface.addAnnotation(new JClassAnnotationImpl(String.format(
            "Path(\"%s\")", this.properties.getProperty(MidGen4JRESTModule.BASE_PATH_KEY))));
    this.addRequiredImport("javax.ws.rs.Path");

    // Add member variable for service provider
    this.addServiceProvider(restInterface);

    return restInterface;
  }

  /**
   * Create annotated method to handle REST requests. Each generated
   * method will pass the incoming message (if any) to the central
   * service provider and return a result message (if any).
   *
   * @param operation FOperation object from WSDL parser
   *
   * @return JMethod object with request handler method
   *
   * @throws Exception Error during code generation
   */
  private JMethod createRequestHandlerMethod(final FOperation operation) throws Exception
  {
    // Create input argument
    JParameter methodInput = null;

    // Operation has an input value
    if (null != operation.getInputMessage())
    {
      String inputMessageClassName = MidGen4JRESTHandler.firstLetterCapital(
              operation.getInputMessage().getMessageAttribute().getLocalPart()) + "Message";

      methodInput = JParameter.factory.create(
              JModifier.FINAL,
              inputMessageClassName,
              "inputMessage");

      // Add required import for input message
      if (!this.packageName.equals(this.serviceProviderPackageName))
      {
        this.addRequiredImport(this.serviceProviderPackageName + "." + inputMessageClassName);
      }
    }

    // Create method signature
    JMethodSignature jms = JMethodSignature.factory.create(methodInput);

    // Create output argument
    String methodOutput = "void";
    if (null != operation.getOutputMessage())
    {
      methodOutput = MidGen4JRESTHandler.firstLetterCapital(
              operation.getOutputMessage().getMessageAttribute().getLocalPart()) + "Message";

      // Add required import for output message
      if (!this.packageName.equals(this.serviceProviderPackageName))
      {
        this.addRequiredImport(this.serviceProviderPackageName + "." + methodOutput);
      }
    }

    // Create request handler
    JMethod method = JMethod.factory.create(
            JModifier.PUBLIC,
            methodOutput,
            operation.getOperationName(),
            jms);

    LOGGER.debug(String.format("Created REST request handler for service operation '%s'.",
            operation.getOperationName()));

    // Set method body
    String methodBody = String.format(
            "%sthis.serviceProvider.%s(%s);",
            (null != operation.getOutputMessage() ? "return " : ""), // Method has return value?
            operation.getOperationName(),
            (null != operation.getInputMessage() ? "inputMessage" : "")); // Method has input?
    method.getBody().appendSource(methodBody);

    // Add a comment
    method.setComment(new JMethodCommentImpl(String.format(
            "The '%s' request handler.", operation.getOperationName())));

    // Add annotations for JAX-RS/Jersey
    this.addJerseyAnnotations(operation, method);

    return method;
  }

  /**
   * Add a member variable and a constructor to the REST interface
   * class that is passed to this method. The member variable will
   * represent an instance of the central service provider class.
   * The constructor will be used to simply instantiate the service
   * provider object.
   *
   * @param restInterface RESTful service interface class
   *
   * @throws Exception Error during code generation
   */
  private void addServiceProvider(final JClass restInterface) throws Exception
  {
    String serviceProviderClassName = this.properties.getProperty(MidGen4JRESTModule.SERVICE_PROVIDER_CLASS_NAME_KEY);

    // Add import for service provider class
    if (!this.packageName.equals(this.serviceProviderPackageName))
    {
      this.addRequiredImport(this.serviceProviderPackageName + "." + serviceProviderClassName);
    }

    // Create member variable
    JField member = JField.factory.create(JModifier.PRIVATE, serviceProviderClassName, "serviceProvider");
    member.setComment(new JFieldCommentImpl("The service provider instance."));
    restInterface.add(member);

    // Create constructor
    JConstructor constructor = JConstructor.factory.create(JModifier.PUBLIC, this.restInterfaceClassName);

    // Set method body
    String methodBody = String.format(
            "this.serviceProvider = new %s();",
            serviceProviderClassName);
    constructor.getBody().setSource(methodBody);

    // Add a comment
    constructor.setComment(new JMethodCommentImpl(String.format(
            "The '%s' constructor.", this.restInterfaceClassName)));

    restInterface.add(constructor);
  }

  /**
   * Add a main method to the REST interface class. This allows to
   * start an instance of the built-in HTTP webserver that comes
   * with Java. That way application developers can easily test
   * the REST interface of their service provider.
   *
   * @param restInterface RESTful service interface class
   *
   * @throws Exception Error during code generation
   */
  private void addMainMethod(final JClass restInterface) throws Exception
  {
    // Create method parameter
    JParameter argumentList = JParameter.factory.create(JModifier.NONE, "String[]", "args");

    // Create method signature
    JMethodSignature jms = JMethodSignature.factory.create(argumentList);

    // Create main method
    JMethod mainMethod = JMethod.factory.create(JModifier.PUBLIC | JModifier.STATIC,
            "void", "main", jms, new String[] { "Exception" });

    // Set method body
    String methodBody = String.format(
            "HttpServer server = HttpServerFactory.create(\"%s\");\n\n" +
            "server.start();\n" +
            "JOptionPane.showMessageDialog(null, \"Click 'OK' to stop server.\", " +
            "\"REST Interface Control\", JOptionPane.WARNING_MESSAGE);\n" +
            "server.stop(0);",
            this.properties.getProperty(MidGen4JRESTModule.BASE_URL_KEY));
    mainMethod.getBody().setSource(methodBody);

    // Add required imports to class
    this.addRequiredImport("com.sun.net.httpserver.HttpServer");
    this.addRequiredImport("com.sun.jersey.api.container.httpserver.HttpServerFactory");
    this.addRequiredImport("javax.swing.JOptionPane");

    // Add a comment
    mainMethod.setComment(new JMethodCommentImpl("The application's main method."));

    restInterface.add(mainMethod);
  }

  /**
   * Add JAX-RS/Jersey annotations to the REST request handler that
   * is passed in as second parameter. The FOperation object in the
   * first argument will be used to determine, which annotations
   * are needed (i.e. if the operation has an input and/or output
   * message).
   *
   * Furthermore, required Java imports will be added to the REST
   * interface class automatically.
   *
   * @param operation FOperation object with information about the
   * operation's input and output message
   * @param method JMethod object to add JAX-RS/Jersey annotations
   */
  private void addJerseyAnnotations(final FOperation operation, final JMethod method)
  {
    // Operation has input argument
    if (null != operation.getInputMessage())
    {
      method.addAnnotation(new JMethodAnnotationImpl("POST"));
      this.addRequiredImport("javax.ws.rs.POST");

      method.addAnnotation(new JMethodAnnotationImpl(String.format(
              "Consumes(%s)", this.properties.getProperty(MidGen4JRESTModule.CONSUMED_MIME_TYPES_KEY))));
      this.addRequiredImport("javax.ws.rs.Consumes");
    }
    // Operation has no input argument
    else
    {
      method.addAnnotation(new JMethodAnnotationImpl("GET"));
      this.addRequiredImport("javax.ws.rs.GET");
    }

    // Operation has output argument
    if (null != operation.getOutputMessage())
    {
      method.addAnnotation(new JMethodAnnotationImpl(String.format(
              "Produces(%s)", this.properties.getProperty(MidGen4JRESTModule.PRODUCED_MIME_TYPES_KEY))));
      this.addRequiredImport("javax.ws.rs.Produces");
    }

    // Always add REST path
    method.addAnnotation(new JMethodAnnotationImpl(
            String.format("Path(\"%s\")", operation.getOperationName())));
    this.addRequiredImport("javax.ws.rs.Path");
  }

  /**
   * Private helper method to add an import to the internal list
   * of required imports. All entries will later be written to
   * the Java source file.
   *
   * Multiple calls to this function with the same argument will
   * result in a single import statement on source code write-out.
   *
   * @param requiredImport Name of required import
   */
  private void addRequiredImport(final String requiredImport)
  {
    if (null != requiredImport && !this.requiredImports.contains(requiredImport))
    {
      this.requiredImports.add(requiredImport);
    }
  }

  /**
   * Private helper method to capitalize the first letter of a string.
   * Function will return null, if argument was null.
   *
   * @param text Text to process
   *
   * @return Text with first letter capitalized or null
   */
  private static String firstLetterCapital(final String text)
  {
    return (null == text ? null : text.substring(0, 1).toUpperCase() + text.substring(1, text.length()));
  }
}
