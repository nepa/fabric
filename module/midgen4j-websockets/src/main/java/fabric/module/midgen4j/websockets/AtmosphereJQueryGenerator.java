/** 16.11.2012 00:41 */
package fabric.module.midgen4j.websockets;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.util.Set;
import java.util.HashSet;
import java.util.Properties;

import de.uniluebeck.sourcegen.Workspace;
import de.uniluebeck.sourcegen.js.JSClass;
import de.uniluebeck.sourcegen.js.JSCommentImpl;
import de.uniluebeck.sourcegen.js.JSField;
import de.uniluebeck.sourcegen.js.JSFunction;
import de.uniluebeck.sourcegen.js.JSMethod;
import de.uniluebeck.sourcegen.js.JSSourceFile;
import de.uniluebeck.sourcegen.plaintext.PlainTextFile;
import fabric.module.api.FDefaultWSDLHandler;

import fabric.wsdlschemaparser.wsdl.FOperation;
import fabric.wsdlschemaparser.wsdl.FPortType;

/**
 * Fabric handler class to extend the Java Middleware Generator. This
 * handler is part of the MidGen4J-WebSockets extension and generates
 * the client-side code to use the Atmosphere framework. Atmosphere
 * provides technical means to connect both, a Java server and a
 * JavaScript client, via WebSockets and variety of other Comet
 * technologies (e.g. streaming and long-polling).
 *
 * On the client-side, Atmosphere uses the jQuery library to open
 * a WebSocket connection and manage all messages. However, the
 * code that is generated by this Fabric handler, will also create
 * a dispatcher class that implements a higher-level RPC protocol
 * on top of WebSockets.
 *
 * For more information about the Atmoshere framework see:
 *   https://github.com/Atmosphere/atmosphere
 *
 * @author seidel
 */
public class AtmosphereJQueryGenerator extends FDefaultWSDLHandler
{
  /** Logger object */
  private static final Logger LOGGER = LoggerFactory.getLogger(AtmosphereJQueryGenerator.class);

  /** Name of the WebSockets test client in HTML file */
  public static final String TEST_CLIENT_NAME = "MidGen4J-WebSockets Test Client";

  /** Workspace object for code write-out */
  private Workspace workspace;

  /** Properties object for module configuration */
  private Properties properties;

  /** Service operations from WSDL file */
  private Set<FOperation> operations;

  /**
   * Constructor initializes the AtmosphereJQueryGenerator, which
   * can create the client-side part of the WebSockets service
   * interface.
   *
   * @param workspace Workspace object for source code write-out
   * @param properties Properties object with module options
   */
  public AtmosphereJQueryGenerator(Workspace workspace, Properties properties) throws Exception
  {
    this.workspace = workspace;
    this.properties = properties;

    this.operations = new HashSet<FOperation>();
  }

  /**
   * Create JavaScript code to control the Atmosphere framework and
   * to provide a higher-level RPC protocol on top of WebSockets,
   * before processing any other element of the WSDL document.
   *
   * @throws Exception Error during code generation
   */
  @Override
  public void executeBeforeProcessing() throws Exception
  {
    JSSourceFile jssf = this.workspace.getJavaScript().getJSSourceFile(
            this.packageNameToPath(this.properties.getProperty(MidGen4JWebSocketsModule.PACKAGE_NAME_KEY)),
            this.properties.getProperty(MidGen4JWebSocketsModule.JS_APPLICATION_NAME_KEY));

    // Add code before fields
    jssf.getCodeBeforeFields().setCode("\'use strict\';");

    // Add global fields
    jssf.add(JSField.factory.create("socket").setComment(new JSCommentImpl("Reference to Atmosphere\'s main client object.")));
    jssf.add(JSField.factory.create("request").setComment(new JSCommentImpl("Object for sending requests to server.")));
    jssf.add(JSField.factory.create("subSocket").setComment(new JSCommentImpl("Subscribed socket with actual connection to server.")));
    jssf.add(JSField.factory.create("dispatcher").setComment(new JSCommentImpl("Manager for tracked RPC method calls.")));

    // Create GUID and dispatcher class
    jssf.add(this.createGUIDClass());
    jssf.add(this.createDispatcherClass());

    // Add global function to open connection
    JSFunction openConnection = JSFunction.factory.create("openConnection");
    openConnection.setComment(new JSCommentImpl("Open connection to server."));
    String methodBody =
            "subSocket = socket.subscribe(request);\n\n" +
            "dispatcher = new Dispatcher(subSocket);";
    openConnection.getBody().setCode(methodBody);
    jssf.add(openConnection);

    // Add global function to close connection
    JSFunction closeConnection = JSFunction.factory.create("closeConnection");
    closeConnection.setComment(new JSCommentImpl("Close connection to server."));
    methodBody = "socket.unsubscribe();";
    closeConnection.getBody().setCode(methodBody);
    jssf.add(closeConnection);

    // Add global function to send message
    JSFunction sendMessage = JSFunction.factory.create("sendMessage", "message");
    sendMessage.setComment(new JSCommentImpl("Send untracked message to server."));
    methodBody =
            "// This bypasses the tracking mechanism!\n" +
            "subSocket.push(message);";
    sendMessage.getBody().setCode(methodBody);
    jssf.add(sendMessage);

    // Add code to end of file
    jssf.getCodeAfterFunctions().setCode(this.createAtmosphereJQueryCode());
  }

  /**
   * Create a test client in HTML with controls to call each RPC
   * method from a webbrowser. Furthermore, generate JavaScript
   * code for all service operations.
   *
   * The service operations will be collected in processPortTypes()
   * and can then be used further here, after processing any other
   * element of the WSDL document.
   *
   * @throws Exception Error during code generation
   */
  @Override
  public void executeAfterProcessing() throws Exception
  {
    // Create test client with RPC controls
    this.createTestClient(this.operations);

    // Create JavaScript code with RPC methods
    for (FOperation operation: this.operations)
    {
      this.addRpcMethod(operation);
    }
  }

  /**
   * Process port types (WSDL 2.0: interfaces) that are defined in WSDL document.
   *
   * @param portTypes Port types of WSDL document
   *
   * @throws Exception Error during processing
   */
  @Override
  public void processPortTypes(final HashSet<FPortType> portTypes) throws Exception
  {
    // Process all service operations
    for (FPortType portType: portTypes)
    {
      for (FOperation operation: portType.getOperations())
      {
        // Collect all service operations
        this.operations.add(operation);
      }
    }
  }

  /**
   * Create a JavaScript class that can generate globally unique
   * identifiers (GUIDs). The GUIDs will later be used to identify
   * messages, which are sent accross the WebSocket connection to
   * call remote methods.
   *
   * @return JSClass object with GUID generator class
   *
   * @throws Exception Error during code generation
   */
  private JSClass createGUIDClass() throws Exception
  {
    // Create GUID class
    JSClass guidClass = JSClass.factory.create("GUID");
    guidClass.setComment(new JSCommentImpl("Helper class to generate unique IDs."));

    // Create helper method to generate random strings
    JSMethod s4 = JSMethod.factory.create("S4");
    s4.setComment(new JSCommentImpl("Create a block of four random characters."));
    String methodBody =
            "return Math.floor(\n" +
            "\tMath.random() * 0x10000 /* 65536 */\n" +
            ").toString(16);";
    s4.getBody().setCode(methodBody);
    guidClass.add(s4);

    // Create a method to generate GUIDs
    JSMethod create = JSMethod.factory.create("create");
    create.setComment(new JSCommentImpl("Return a new GUID."));
    methodBody =
            "return (\n" +
            "\tthis.S4() + this.S4() + \'-\' +\n" +
            "\tthis.S4() + \'-\' +\n" +
            "\tthis.S4() + \'-\' +\n" +
            "\tthis.S4() + \'-\' +\n" +
            "\tthis.S4() + this.S4() + this.S4()\n" +
            ");";
    create.getBody().setCode(methodBody);
    guidClass.add(create);

    return guidClass;
  }

  /**
   * Create a JavaScript class that can track WebSocket messages
   * by their unique ID and is able to dispatch responses the
   * custom callback functions, that were defined before issuing
   * the RPC method call.
   *
   * @return JSClass object with dispatcher class
   *
   * @throws Exception Error during code generation
   */
  private JSClass createDispatcherClass() throws Exception
  {
    // Create dispatcher class
    JSClass dispatcherClass = JSClass.factory.create("Dispatcher", "subSocket");
    dispatcherClass.setComment(new JSCommentImpl("Dispatcher class to handle RPC methods and track messages."));

    // Add member field for delimiter
    JSField delimiter = JSField.factory.create("delimiter", "\'$\'");
    delimiter.setComment(new JSCommentImpl("Delimiter for protocol parts."));
    dispatcherClass.add(delimiter);

    // Add member field for connection to server
    JSField socket = JSField.factory.create("socket", "subSocket");
    socket.setComment(new JSCommentImpl("Connection to server."));
    dispatcherClass.add(socket);

    // Add member field for pending messages
    JSField pendingMessages = JSField.factory.create("pendingMessages", "new Object()");
    pendingMessages.setComment(new JSCommentImpl("List of pending messages."));
    dispatcherClass.add(pendingMessages);

    // Add method to do a tracked RPC method call
    JSMethod trackedCall = JSMethod.factory.create("trackedCall", "method", "payload", "callback");
    trackedCall.setComment(new JSCommentImpl("Execute tracked RPC method call."));
    String methodBody =
            "var uuid = new GUID().create();\n\n" +
            "// Add call to pending messages\n" +
            "this.pendingMessages[uuid] = callback;\n\n" +
            "console.log(\'Now tracking call of method \' + method + \' with GUID \' + uuid + \'.\');\n\n" +
            "this.socket.push(uuid + this.delimiter + method + this.delimiter + payload);";
    trackedCall.getBody().setCode(methodBody);
    dispatcherClass.add(trackedCall);

    // Add method to dispatch response messages
    JSMethod dispatch = JSMethod.factory.create("dispatch", "response");
    dispatch.setComment(new JSCommentImpl("Dispatch response to a tracked message."));
    methodBody =
            "var data = response.split(this.delimiter);\n\n" +

            "if (data.length != 3) {\n" +
            "\tconsole.log(\'Invalid response format.\');\n" +
            "}\n" +
            "else {\n" +
            "\tvar uuid = data[0];\n" +
            "\tvar method = data[1];\n" +
            "\tvar payload = data[2];\n\n" +

            "\t// UUID lookup\n" +
            "\tif (!(uuid in this.pendingMessages)) {\n" +
            "\t\tconsole.log(\'Response with untracked message ID.\');\n" +
            "\t}\n" +
            "\telse {\n" +
            "\t\t// Pass payload to registered callback\n" +
            "\t\tif (this.pendingMessages[uuid] != undefined && typeof this.pendingMessages[uuid] == 'function') {\n" +
            "\t\t\tconsole.log(\'Now dispatching result of method \' + method + \' with UUID \' + uuid + \'.\');\n\n" +

            "\t\t\t// Execute callback method\n" +
            "\t\t\tthis.pendingMessages[uuid](payload);\n\n" +

            "\t\t\t// Remove call from pending list\n" +
            "\t\t\tdelete this.pendingMessages[uuid];\n" +
            "\t\t}\n" +
            "\t\telse {\n" +
            "\t\t\tconsole.log(\'Could not execute callback.\');\n" +
            "\t\t}\n" +
            "\t}\n" +
            "}";
    dispatch.getBody().setCode(methodBody);
    dispatcherClass.add(dispatch);

    return dispatcherClass;
  }

  /**
   * Create code that is executed by jQuery, as soon as the DOM tree
   * finished loading. The code is used to define parameters for the
   * WebSockets connection and to declare callback methods on the
   * request object which is provided by the Atmosphere framework.
   *
   * @return String with a block of JavaScript code
   */
  private String createAtmosphereJQueryCode()
  {
    String codeBlock = "";

    codeBlock = String.format(
            "/**\n" +
            " * Establish connection to server and define callbacks.\n" +
            " *\n" +
            " * Will be called by jQuery, as soon as DOM is ready.\n" +
            " */\n" +
            "$(function()\n" +
            "{\n" +
            "\tsocket = $.atmosphere;\n\n" +

            "\t// Also see:\n" +
            "\t//   https://github.com/Atmosphere/atmosphere/wiki/jQuery.atmosphere.js-API\n" +
            "\trequest = new $.atmosphere.AtmosphereRequest();\n" +
            "\trequest.url = document.location.toString() + \'%s\';\n" +
            "\trequest.contentType = \'application/json\';\n" +
            "\trequest.transport = \'%s\';\n" +
            "\trequest.fallbackTransport = \'%s\';\n" +
            "\trequest.shared = true;\n" +
            "\trequest.enableXDR = true;\n" +
            "\trequest.headers = { \'Access-Control-Allow-Origin\': \'*\' };\n\n" + // TODO: Do we really need this?

            "\trequest.onOpen = function(response) {\n" +
            "\t\tconsole.log(\'Connection opened.\');\n" +
            "\t}\n\n" +

            "\trequest.onClose = function(response) {\n" +
            "\t\tconsole.log(\'Connection closed.\');\n" +
            "\t}\n\n" +

            "\trequest.onTransportFailure = function(request) {\n" +
            "\t\tconsole.log(\'This browser or the remote server does not support WebSockets.\');\n" +
            "\t}\n\n" +

            "\trequest.onMessage = function(response) {\n" +
            "\t\tvar message = response.responseBody;\n\n" +
            "\t\tconsole.log(\'Message received: \' + message);\n" +
            "\t\tdispatcher.dispatch(message);\n" +
            "\t}\n" +

            "});",
            this.properties.getProperty(MidGen4JWebSocketsModule.CHANNEL_NAME_KEY),
            this.properties.getProperty(MidGen4JWebSocketsModule.TRANSPORT_KEY),
            this.properties.getProperty(MidGen4JWebSocketsModule.FALLBACK_TRANSPORT_KEY));

    return codeBlock;
  }

  /**
   * Create a test client in HTML that can be used to call each
   * RPC method of MidGen4J's central service provider. The client
   * can be run in any webbrowser with WebSockets support.
   *
   * @param operations Service operations that need controls
   */
  private void createTestClient(final Set<FOperation> operations)
  {
    PlainTextFile textFile = this.workspace.getPlainText().getPlainTextFile(
            this.properties.getProperty(MidGen4JWebSocketsModule.PROJECT_PATH_KEY) + "/webapp",
            "index", "html");

    // Create controls to call RPC methods
    String rpcControls = "";
    for (FOperation operation: operations)
    {
      rpcControls += String.format(
              "  <h3 class=\"control\" onClick=\"%s();\">Call %s()</h3>\n",
              operation.getOperationName(), operation.getOperationName());
    }

    // Create file content
    String fileContent = String.format(
"<!DOCTYPE html>\n" +
"<html>\n\n" +

"<head>\n" +
"  <title>%s</title>\n\n" +

"  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n\n" +

"  <script type=\"text/javascript\" src=\"./jquery/jquery-1.7.2.js\"></script>\n" +
"  <script type=\"text/javascript\" src=\"./jquery/jquery.atmosphere.js\"></script>\n" +
"  <script type=\"text/javascript\" src=\"./application.js\"></script>\n\n" +

"  <style type=\"text/css\">\n" +
"    h3.control\n" +
"    {\n" +
"      cursor: pointer;\n" +
"    }\n" +
"  </style>\n" +
"</head>\n\n" +

"<body>\n" +
"  <h1>%s</h1>\n\n" +

"  <h3 class=\"control\" onClick=\"openConnection();\">Open connection</h3>\n" +
"  <h3 class=\"control\" onClick=\"sendMessage('Hello World!');\">Send untracked message</h3>\n" +
"%s" +
"  <h3 class=\"control\" onClick=\"closeConnection();\">Close connection</h3>\n" +
"</body>\n\n" +

"</html>",
            TEST_CLIENT_NAME, TEST_CLIENT_NAME, rpcControls);

    textFile.getContent().setCode(fileContent);
  }

  /**
   * Add a global function to the JavaScript application, so that
   * the corresponding RPC method can be called from the WebSockets
   * test client.
   *
   * @param operation Service operation to add as global function
   *
   * @throws Exception Error during code generation
   */
  private void addRpcMethod(final FOperation operation) throws Exception
  {
    JSSourceFile jssf = this.workspace.getJavaScript().getJSSourceFile(
            this.packageNameToPath(this.properties.getProperty(MidGen4JWebSocketsModule.PACKAGE_NAME_KEY)),
            this.properties.getProperty(MidGen4JWebSocketsModule.JS_APPLICATION_NAME_KEY));

    String name = operation.getOperationName();
    String inputMessage = (null == operation.getInputMessage() ? "{}" : "{ /* TODO: Add your custom JSON code here */ }");

    // Add global function to call RPC method
    JSFunction rpcFunction = JSFunction.factory.create(name);
    rpcFunction.setComment(new JSCommentImpl(String.format("Call the '%s' remote method.", name)));

    // Set method body
    String methodBody = String.format(
            "if (dispatcher != undefined) {\n" +
            "\tdispatcher.trackedCall(\'%s\', JSON.stringify(%s),\n" +
            "\t\tfunction(response) {\n" +
            "\t\t\tconsole.log('Got response to %s() request: ' + JSON.parse(response).result);\n" +
            "\t\t});\n" +
            "\t}\n" +
            "}",
            name, inputMessage, name);
    rpcFunction.getBody().setCode(methodBody);

    jssf.add(rpcFunction);
  }

  /**
   * Private helper method to convert a Java package name to
   * a relative path that can be used in a file system (i.e.
   * replace all dots with platform-specific separators).
   *
   * @param javaPackageName Java package name
   *
   * @return File path equivalent to Java package name
   */
  private String packageNameToPath(final String javaPackageName)
  {
    return javaPackageName.replace('.', File.separatorChar);
  }
}
