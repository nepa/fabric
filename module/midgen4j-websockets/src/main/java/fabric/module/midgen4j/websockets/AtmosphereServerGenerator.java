/** 10.03.2013 17:22 */
package fabric.module.midgen4j.websockets;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Properties;

import de.uniluebeck.sourcegen.Workspace;
import de.uniluebeck.sourcegen.java.JClass;
import de.uniluebeck.sourcegen.java.JClassAnnotationImpl;
import de.uniluebeck.sourcegen.java.JClassCommentImpl;
import de.uniluebeck.sourcegen.java.JConstructor;
import de.uniluebeck.sourcegen.java.JConstructorCommentImpl;
import de.uniluebeck.sourcegen.java.JField;
import de.uniluebeck.sourcegen.java.JFieldCommentImpl;
import de.uniluebeck.sourcegen.java.JMethod;
import de.uniluebeck.sourcegen.java.JMethodAnnotationImpl;
import de.uniluebeck.sourcegen.java.JMethodCommentImpl;
import de.uniluebeck.sourcegen.java.JMethodSignature;
import de.uniluebeck.sourcegen.java.JModifier;
import de.uniluebeck.sourcegen.java.JParameter;
import de.uniluebeck.sourcegen.java.JSourceFile;
import fabric.module.api.FDefaultWSDLHandler;

/**
 * Fabric handler class to extend the Java Middleware Generator. This
 * handler is part of the MidGen4J-WebSockets extension and generates
 * the server-side code to use the Atmosphere framework. Atmosphere
 * provides technical means to connect both, a Java server and a
 * JavaScript client, via WebSockets and a variety of other Comet
 * technologies (e.g. streaming and long-polling).
 *
 * On the server-side, Atmosphere uses its own AtmosphereServlet class
 * to handle incoming requests and send response messages accordingly.
 * However, the code that is generated by this Fabric handler, will
 * also create a dispatching mechanism that implements a higher-level
 * RPC protocol on top of WebSockets.
 *
 * For more information about the Atmoshere framework see:
 *   https://github.com/Atmosphere/atmosphere
 *
 * @author seidel
 */
public class AtmosphereServerGenerator extends FDefaultWSDLHandler
{
  // TODO: Implement class

  /** Logger object */
  private static final Logger LOGGER = LoggerFactory.getLogger(AtmosphereServerGenerator.class); // TODO: Use logger in class

  /** Name of the WebSockets server class */
  public static final String SERVER_CLASS_NAME = "Server"; // TODO: Use MidGen4JWebSocketsModule.INTERFACE_CLASS_NAME_KEY instead?

  /** Workspace object for code write-out */
  private Workspace workspace;

  /** Properties object for module configuration */
  private Properties properties;

  /** Java package name for WebSocket interface classes */
  private String packageName;

  /** Name of broadcast channel */
  private String channelName;

  /** Name of the service provider class */
  private String serviceProviderClassName;

  /**
   * Constructor initializes the AtmosphereServerGenerator, which
   * can create the server-side part of the WebSockets service
   * interface.
   *
   * @param workspace Workspace object for source code write-out
   * @param properties Properties object with module options
   */
  public AtmosphereServerGenerator(Workspace workspace, Properties properties) throws Exception
  {
    this.workspace = workspace;
    this.properties = properties;

    // Extract global properties
    this.packageName = this.properties.getProperty(MidGen4JWebSocketsModule.PACKAGE_NAME_KEY);
    this.channelName = this.properties.getProperty(MidGen4JWebSocketsModule.CHANNEL_NAME_KEY);
    this.serviceProviderClassName = this.properties.getProperty(MidGen4JWebSocketsModule.SERVICE_PROVIDER_CLASS_NAME_KEY);
  }

  /**
   * Create a Java class that contains the WebSockets server,
   * before processing any other element of the WSDL document.
   *
   * @throws Exception Error during code generation
   */
  @Override
  public void executeAfterProcessing() throws Exception
  {
    this.createWebSocketsServerFile();
  }

  /**
   * Create a source file that contains the WebSockets server.
   * The method will generate the corresponding Java class and
   * add all necessary Java imports to the file.
   *
   * @throws Exception Error during code generation
   */
  private void createWebSocketsServerFile() throws Exception
  {
    JSourceFile jsf = this.workspace.getJava().getJSourceFile(this.packageName, SERVER_CLASS_NAME);

    // Add WebSockets server class
    jsf.add(this.createWebSocketsServerClass());

    // TODO: Add required imports to source file
  }

  /**
   * Create WebSockets server class and add all neccessary
   * fields and methods to it. The created class extends
   * the WebSocketHandlerAdapter, which defines most of
   * the callbacks that are needed to handle requests of
   * a remote client.
   *
   * @return JClass object with WebSockets server class
   *
   * @throws Exception Error during code generation
   */
  private JClass createWebSocketsServerClass() throws Exception
  {
    JClass serverClass = JClass.factory.create(JModifier.PUBLIC, SERVER_CLASS_NAME);
    serverClass.setExtends("WebSocketHandlerAdapter");
    serverClass.addAnnotation(new JClassAnnotationImpl(String.format(
            "WebSocketHandlerService(path = \"/%s\"})", this.channelName)));
    serverClass.setComment(new JClassCommentImpl(String.format("The '%s' class.", SERVER_CLASS_NAME)));

    // Add fields to class
    for (JField field: this.createFields())
    {
      serverClass.add(field);
    }

    // Add methods to class
    serverClass.add(this.createConstructor());
    serverClass.add(this.createOnOpenMethod());
    serverClass.add(this.createOnCloseMethod());
    serverClass.add(this.createOnTextMessage());
    serverClass.add(this.createBuildResponse());
    serverClass.add(this.createSendMessage());
    serverClass.add(this.createBroadcastMessage());

    return serverClass;
  }

  /**
   * Create all fields of the class and return them as an
   * ArrayList. The field list contains both constants and
   * member variables.
   *
   * @return List of JField objects for class
   *
   * @throws Exception Error during code generation
   */
  private ArrayList<JField> createFields() throws Exception
  {
    ArrayList<JField> fields = new ArrayList<JField>();

    // Create LOGGER constant
    JField logger = JField.factory.create(JModifier.PRIVATE | JModifier.STATIC | JModifier.FINAL,
            "Logger", "LOGGER", String.format("LoggerFactory.getLogger(%s.class)", SERVER_CLASS_NAME));
    logger.setComment(new JFieldCommentImpl("Logger object."));
    fields.add(logger);

    // Create DELIMITER constant
    JField delimiter = JField.factory.create(JModifier.PRIVATE | JModifier.STATIC | JModifier.FINAL,
            "char", "DELIMITER", "'$'");
    delimiter.setComment(new JFieldCommentImpl("Delimiting character for RCP protocol."));
    fields.add(delimiter);

    // Create ServiceProvider object
    JField serviceProvider = JField.factory.create(JModifier.PRIVATE, this.serviceProviderClassName, "serviceProvider");
    serviceProvider.setComment(new JFieldCommentImpl("Service provider object."));
    fields.add(serviceProvider);

    return fields;
  }

  // TODO: Add comment
  private JConstructor createConstructor() throws Exception
  {
    JConstructor constructor = JConstructor.factory.create(JModifier.PUBLIC, SERVER_CLASS_NAME);
    constructor.setComment(new JConstructorCommentImpl(String.format("Create new '%s' object.", SERVER_CLASS_NAME)));

    // Set method body
    String methodBody = String.format(
            "LOGGER.info(\"WebSockets server created.\");\n\n" +
            "this.serviceProvider = new %s();",
            this.serviceProviderClassName);
    constructor.getBody().setSource(methodBody);

    return constructor;
  }

  // TODO: Add comment
  private JMethod createOnOpenMethod() throws Exception
  {
    JParameter webSocket = JParameter.factory.create("WebSocket", "webSocket");
    JMethodSignature jms = JMethodSignature.factory.create(webSocket);

    JMethod onOpen = JMethod.factory.create(JModifier.PUBLIC, "void", "onOpen", jms);
    onOpen.addAnnotation(JMethodAnnotationImpl.OVERRIDE);
    onOpen.setComment(new JMethodCommentImpl("Callback for newly opened connection."));

    // Set method body
    String methodBody = String.format(
            "LOGGER.info(\"WebSocket opened.\");\n\n" +

            "// Subscribe current WebSocket to channel '/%s'\n" +
            "webSocket.resource().setBroadcaster(BroadcasterFactory.getDefault().lookup(\"/%s\", true));\n\n" +

            "// Send message\n" +
            "%s.broadcastMessage(\"/%s\", \"Server opened connection.\"); // TODO: Do NOT broadcast to ALL clients!",
            this.channelName, this.channelName,
            SERVER_CLASS_NAME, this.channelName);
    onOpen.getBody().setSource(methodBody);

    return onOpen;
  }

  // TODO: Add comment
  private JMethod createOnCloseMethod() throws Exception
  {
    JParameter webSocket = JParameter.factory.create("WebSocket", "webSocket");
    JMethodSignature jms = JMethodSignature.factory.create(webSocket);

    JMethod onClose = JMethod.factory.create(JModifier.PUBLIC, "void", "onClode", jms);
    onClose.addAnnotation(JMethodAnnotationImpl.OVERRIDE);
    onClose.setComment(new JMethodCommentImpl("Callback for recently closed connection."));

    // Set method body
    String methodBody =
            "LOGGER.info(\"WebSocket closed.\");\n\n" +

            "// Remove WebSocket from broadcasting channel\n" +
            "BroadcastFactory.getDefault().removeAllAtmosphereResource(webSocket.resource());";
    onClose.getBody().setSource(methodBody);
    
    return onClose;
  }
  
  // TODO: Add comment
  private JMethod createOnTextMessage() throws Exception
  {
    JParameter webSocket = JParameter.factory.create("WebSocket", "webSocket");
    JParameter message = JParameter.factory.create("String", "message");
    JMethodSignature jms = JMethodSignature.factory.create(webSocket, message);

    JMethod onTextMessage = JMethod.factory.create(JModifier.PUBLIC, "void", "onTextMessage", jms);
    onTextMessage.addAnnotation(JMethodAnnotationImpl.OVERRIDE);
    onTextMessage.setComment(new JMethodCommentImpl("Callback for received message."));

    // Set method body
    String methodBody =
            "// TODO"; // TODO: Create method body
    onTextMessage.getBody().setSource(methodBody);

    return onTextMessage;
  }

  // TODO: Add comment
  private JMethod createBuildResponse() throws Exception
  {
    JParameter uuid = JParameter.factory.create(JModifier.FINAL, "String", "uuid");
    JParameter method = JParameter.factory.create(JModifier.FINAL, "String", "method");
    JParameter payload = JParameter.factory.create(JModifier.FINAL, "String", "payload");
    JMethodSignature jms = JMethodSignature.factory.create(uuid, method, payload);

    JMethod buildResponse = JMethod.factory.create(JModifier.PUBLIC | JModifier.STATIC,
            "String", "buildResponseMessage", jms);
    buildResponse.setComment(new JMethodCommentImpl("Build a response message according to RPC protocol."));

    // Set method body
    String methodBody = String.format(
            "return uuid + %s.DELIMITER + method + %s.DELIMITER + payload;",
            SERVER_CLASS_NAME, SERVER_CLASS_NAME);
    buildResponse.getBody().setSource(methodBody);

    return buildResponse;
  }

  // TODO: Add comment
  private JMethod createSendMessage() throws Exception
  {
    JParameter webSocket = JParameter.factory.create("WebSocket", "webSocket");
    JParameter message = JParameter.factory.create("String", "message");
    JMethodSignature jms = JMethodSignature.factory.create(webSocket, message);

    JMethod sendMessage = JMethod.factory.create(JModifier.PUBLIC | JModifier.STATIC,
            "void", "sendMessage", jms);
    sendMessage.setComment(new JMethodCommentImpl("Send message to a single client,"));

    // Set method body
    String methodBody =
            "try {\n" +
            "\twebSocket.write(message);\n" +
            "}\n" +
            "catch (Exception e) {\n" +
            "\tLOGGER.error(\"Error: \" + e.getMessage());\n" +
            "}";
    sendMessage.getBody().setSource(methodBody);

    return sendMessage;
  }

  // TODO: Add comment
  private JMethod createBroadcastMessage() throws Exception
  {
    JParameter targetChannel = JParameter.factory.create(JModifier.FINAL, "String", "targetChannel");
    JParameter message = JParameter.factory.create(JModifier.FINAL, "String", "message");
    JMethodSignature jms = JMethodSignature.factory.create(targetChannel, message);

    JMethod broadcastMessage = JMethod.factory.create(JModifier.PUBLIC | JModifier.STATIC,
            "void", "broadcastMessage", jms);
    broadcastMessage.setComment(new JMethodCommentImpl(
            "Broadcast message to all clients that are subscribed to a certain channel."));

    // Set method body
    String methodBody =
            "MetaBroadcaster.getDefault().broadcastTo(targetChannel, message);";
    broadcastMessage.getBody().setSource(methodBody);

    return broadcastMessage;
  }
}
